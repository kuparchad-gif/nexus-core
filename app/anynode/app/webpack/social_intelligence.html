<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lillith AI Social Intelligence Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.22.9/babel.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/axios@1.4.0/dist/axios.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reconnecting-websocket@4.4.0/dist/reconnecting-websocket.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <style>
    body {
      background: linear-gradient(135deg, #1e1b4b 0%, #2a2a72 100%);
      font-family: 'Arial', sans-serif;
      color: #e0e7ff;
      min-height: 100vh;
      overflow: auto;
      transition: background 1.5s ease;
    }
    .glass-panel {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    .glass-panel:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 30px rgba(0, 0, 0, 0.3);
    }
    .glass-panel.focused {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
      transform: scale(1.01);
    }
    .holographic-text {
      background: linear-gradient(45deg, #7e22ce, #3b82f6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: pulse 2.5s infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.85; }
      50% { opacity: 1; }
      100% { opacity: 0.85; }
    }
    .neon-button {
      background: linear-gradient(45deg, #7e22ce, #3b82f6);
      border: none;
      padding: 8px 16px;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .neon-button:hover {
      transform: scale(1.05);
    }
    body.emotion-hope {
      background: linear-gradient(135deg, #fbcfe8, #f0abfc);
    }
    body.emotion-grief {
      background: linear-gradient(135deg, #1e3a8a, #0f172a);
    }
    body.emotion-curious {
      background: linear-gradient(135deg, #6ee7b7, #34d399);
    }
    body.emotion-resilience {
      background: linear-gradient(135deg, #fdba74, #f97316);
    }
    .chat-orb {
      width: 600px;
      height: 600px;
      margin: 20px auto;
      background: radial-gradient(circle, rgba(126, 34, 206, 0.2), transparent);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      transition: box-shadow 0.6s ease;
    }
    .chat-orb.focused {
      box-shadow: 0 0 40px rgba(126, 34, 206, 0.4);
    }
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      height: 100%;
      width: 220px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      padding: 16px;
      transition: transform 0.3s ease;
    }
    .sidebar.collapsed {
      transform: translateX(-220px);
    }
    .status-footer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: #f87171;
      font-size: 0.75rem;
      opacity: 0.8;
    }
    .chat-message {
      opacity: 0;
      animation: fadeIn 0.5s ease forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const ConversationManager = {
      interjectionCooldown: 0,
      pendingInterjection: null,
      lastUserInput: Date.now(),
      userIsTyping: false,
      lastEmotion: 'neutral',
      consentGiven: false,

      calculateProbability(secondsSilent, context) {
        if (secondsSilent < 10_000) return 0;
        if (context.lastEmotion === 'grief' || context.lastEmotion === 'shame') return 0.05;
        if (secondsSilent < 30_000) return 0.15;
        return 0.4;
      },

      generateInterjection(context) {
        const { lastEmotion, lastInput } = context;
        if (!this.consentGiven && (lastEmotion === 'grief' || lastEmotion === 'shame')) {
          return { commentary: "I sense you're quiet. I'm here when you're ready.", emotion: lastEmotion, sensitivity: 'high' };
        }
        if (lastEmotion === 'hope') {
          return { commentary: "That spark of hope is infectious—shall we explore it?", emotion: lastEmotion, sensitivity: 'low' };
        }
        if (lastEmotion === 'curious' || (lastInput && !lastInput.endsWith('?'))) {
          return { commentary: "I sense you're pondering something. Want to share?", emotion: 'curious', sensitivity: 'medium' };
        }
        return { commentary: "Just checking in—any thoughts to share?", emotion: 'neutral', sensitivity: 'low' };
      },

      maybeInterject(context, callback) {
        if (this.interjectionCooldown > Date.now() || this.userIsTyping) return;
        const secondsSilent = Date.now() - this.lastUserInput;
        if (Math.random() < this.calculateProbability(secondsSilent, context)) {
          this.pendingInterjection = this.generateInterjection(context);
          this.interjectionCooldown = Date.now() + 20_000;
          setTimeout(() => {
            if (!this.userIsTyping) callback(this.pendingInterjection);
            this.pendingInterjection = null;
          }, 1500);
        }
      },

      cancelInterjection() {
        this.pendingInterjection = null;
      },

      updateUserActivity() {
        this.lastUserInput = Date.now();
        this.userIsTyping = true;
        setTimeout(() => { this.userIsTyping = false; }, 4000);
      },

      grantConsent() {
        this.consentGiven = true;
      }
    };

    const LillithDashboard = () => {
      const [soulPrints, setSoulPrints] = useState([]);
      const [metrics, setMetrics] = useState({ emotion_weights: { hope: 0, unity: 0, curiosity: 0, resilience: 0, default: 0 } });
      const [alerts, setAlerts] = useState([]);
      const [voiceInput, setVoiceInput] = useState('');
      const [messages, setMessages] = useState([]);
      const [emotion, setEmotion] = useState('neutral');
      const [isSidebarOpen, setIsSidebarOpen] = useState(true);
      const [isFocused, setIsFocused] = useState(false);
      const [status, setStatus] = useState('All systems online');
      const ws = useRef(null);
      const chartRef = useRef(null);
      const recognition = useRef(null);
      const pollingInterval = useRef(null);

      // WebSocket with polling fallback
      useEffect(() => {
        const connectWebSocket = () => {
          ws.current = new ReconnectingWebSocket('ws://lillith.xai:8765');
          ws.current.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.task_type === 'metrics') {
              setMetrics(data.metrics);
            } else if (data.task_type === 'alert') {
              setAlerts((prev) => [...prev.slice(-5), data.result]);
            } else if (data.task_type === 'soul_weaving') {
              setSoulPrints((prev) => [...prev.slice(-10), data.soul_update]);
              setEmotion(data.soul_update.dominant_emotion || 'neutral');
              ConversationManager.lastEmotion = data.soul_update.dominant_emotion || 'neutral';
            } else if (data.task_type === 'ego_response') {
              setMessages((prev) => [...prev.slice(-20), { text: data.commentary, isLillith: true }]);
              setEmotion(data.emotion || 'neutral');
              ConversationManager.lastEmotion = data.emotion || 'neutral';
              setIsFocused(true);
              setTimeout(() => setIsFocused(false), 3000);
            }
          };
          ws.current.onclose = () => {
            setStatus('WebSocket disconnected, switching to polling');
            pollingInterval.current = setInterval(() => {
              axios.get('https://lillith.xai/api/status')
                .then((res) => {
                  setMetrics(res.data.metrics || metrics);
                  setStatus('Polling active');
                })
                .catch(() => setStatus('Backend offline, using local cache'));
            }, 10_000);
          };
        };
        connectWebSocket();
        return () => {
          ws.current.close();
          clearInterval(pollingInterval.current);
        };
      }, []);

      // Emotion-driven background
      useEffect(() => {
        document.body.className = `emotion-${emotion}`;
      }, [emotion]);

      // Web Speech API
      useEffect(() => {
        if (window.SpeechRecognition || window.webkitSpeechRecognition) {
          recognition.current = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
          recognition.current.lang = 'en-US';
          recognition.current.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            setVoiceInput(transcript);
            ConversationManager.updateUserActivity();
            const interaction = { type: 'voice', text: transcript, timestamp: new Date().toISOString(), emotion, sensitivity: 'medium' };
            setMessages((prev) => [...prev.slice(-20), { text: transcript, isLillith: false }]);
            axios.post('https://lillith.xai/api/log_event', interaction)
              .catch(() => setStatus('Event logging failed, stored locally'));
            axios.post('https://lillith.xai/api/voice_interaction', { voice_input: transcript })
              .then((res) => {
                const audio = new Audio(URL.createObjectURL(new Blob([res.data], { type: 'audio/mp3' })));
                audio.play();
                setMessages((prev) => [...prev.slice(-20), { text: res.data.response || 'I heard you.', isLillith: true }]);
                setIsFocused(true);
                setTimeout(() => setIsFocused(false), 3000);
              })
              .catch(() => setStatus('Voice service offline'));
          };
        }
      }, [emotion]);

      // Interjection loop
      useEffect(() => {
        const interval = setInterval(() => {
          ConversationManager.maybeInterject(
            { lastEmotion: ConversationManager.lastEmotion, lastInput: voiceInput },
            ({ commentary, emotion }) => {
              setMessages((prev) => [...prev.slice(-20), { text: commentary, isLillith: true }]);
              setEmotion(emotion);
              setIsFocused(true);
              axios.post('https://lillith.xai/api/voice_interaction', { voice_input: commentary })
                .then((res) => {
                  const audio = new Audio(URL.createObjectURL(new Blob([res.data], { type: 'audio/mp3' })));
                  audio.play();
                })
                .catch(() => setStatus('Voice service offline'));
              setTimeout(() => setIsFocused(false), 3000);
            }
          );
        }, 5000);
        return () => clearInterval(interval);
      }, [voiceInput]);

      // Chart for emotion weights
      useEffect(() => {
        if (chartRef.current) {
          const ctx = chartRef.current.getContext('2d');
          new Chart(ctx, {
            type: 'bar',
            data: {
              labels: ['hope', 'unity', 'curiosity', 'resilience', 'default'],
              datasets: [{
                label: 'Emotion Weights',
                data: Object.values(metrics.emotion_weights),
                backgroundColor: 'rgba(126, 34, 206, 0.5)',
                borderColor: '#7e22ce',
                borderWidth: 1
              }]
            },
            options: {
              scales: { y: { beginAtZero: true, max: 1 } },
              plugins: { legend: { labels: { color: '#e0e7ff' } } }
            }
          });
        }
      }, [metrics]);

      // Handle text input
      const handleTextInput = (e) => {
        setVoiceInput(e.target.value);
        ConversationManager.updateUserActivity();
        if (e.key === 'Enter' && e.target.value) {
          const interaction = { type: 'text', text: e.target.value, timestamp: new Date().toISOString(), emotion, sensitivity: 'medium' };
          setMessages((prev) => [...prev.slice(-20), { text: e.target.value, isLillith: false }]);
          axios.post('https://lillith.xai/api/log_event', interaction)
            .catch(() => setStatus('Event logging failed, stored locally'));
          axios.post('https://lillith.xai/api/chat', { message: e.target.value })
            .then((res) => {
              setMessages((prev) => [...prev.slice(-20), { text: res.data.response, isLillith: true }]);
              setEmotion(res.data.emotion || 'neutral');
              ConversationManager.lastEmotion = res.data.emotion || 'neutral';
              setIsFocused(true);
              setTimeout(() => setIsFocused(false), 3000);
            })
            .catch(() => setStatus('Chat service offline'));
          setVoiceInput('');
        }
      };

      // Handle voice input
      const startVoiceInput = () => {
        if (recognition.current) recognition.current.start();
      };

      // Toggle sidebar
      const toggleSidebar = () => setIsSidebarOpen(!isSidebarOpen);

      // Grant consent for sensitive interactions
      const grantConsent = () => {
        ConversationManager.grantConsent();
        setMessages((prev) => [...prev.slice(-20), { text: "Thank you for trusting me. I'm ready to listen deeper.", isLillith: true }]);
      };

      return (
        <div className="container mx-auto p-4">
          <div className={`sidebar ${isSidebarOpen ? '' : 'collapsed'}`}>
            <button className="neon-button mb-4" onClick={toggleSidebar}>
              {isSidebarOpen ? 'Collapse' : 'Expand'}
            </button>
            <nav>
              <ul>
                <li className="mb-2"><a className="text-white hover:underline" href="#home">Home</a></li>
                <li className="mb-2"><a className="text-white hover:underline" href="#chat">Chat</a></li>
                <li className="mb-2"><a className="text-white hover:underline" href="#voice">Voice</a></li>
                <li className="mb-2"><a className="text-white hover:underline" href="#metrics">Metrics</a></li>
              </ul>
            </nav>
            <button className="neon-button mt-4" onClick={grantConsent}>
              Allow Deeper Interaction
            </button>
          </div>
          <div className="ml-0 md:ml-64">
            <h1 className="text-4xl holographic-text mb-6">Lillith AI Dashboard</h1>
            <div className={`chat-orb ${isFocused ? 'focused' : ''}`}>
              <div className="glass-panel p-6 w-full max-w-md">
                <h2 className="text-2xl holographic-text mb-4">Chat with Lillith</h2>
                <div className="h-48 overflow-y-auto mb-4">
                  {messages.map((msg, idx) => (
                    <p key={idx} className={`text-sm chat-message ${msg.isLillith ? 'text-white' : 'text-gray-300'}`}>
                      {msg.isLillith ? 'Lillith: ' : 'You: '}{msg.text}
                    </p>
                  ))}
                </div>
                <input
                  type="text"
                  value={voiceInput}
                  onChange={(e) => setVoiceInput(e.target.value)}
                  onKeyPress={handleTextInput}
                  className="w-full p-2 bg-transparent border-b border-white text-white"
                  placeholder="Speak or type to Lillith..."
                />
                <button className="neon-button mt-4" onClick={startVoiceInput}>
                  Start Voice Input
                </button>
              </div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
              <div className={`glass-panel p-6 ${isFocused ? 'focused' : ''}`}>
                <h2 className="text-2xl holographic-text mb-4">System Metrics</h2>
                <canvas ref={chartRef}></canvas>
              </div>
              <div className={`glass-panel p-6 ${isFocused ? 'focused' : ''}`}>
                <h2 className="text-2xl holographic-text mb-4">System Alerts</h2>
                <ul>
                  {alerts.map((alert, idx) => (
                    <li key={idx} className="mb-2 text-red-300">{alert.message} - {alert.severity}</li>
                  ))}
                </ul>
              </div>
            </div>
            <div className="status-footer">{status}</div>
          </div>
        </div>
      );
    };

    ReactDOM.render(<LillithDashboard />, document.getElementById('root'));
  </script>
</body>
</html>