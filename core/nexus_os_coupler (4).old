# galactic_nexus_coupler.py
import modal
import asyncio
import time
import uuid
import threading
import logging
from typing import Dict, List, Any, Optional
import json
import requests
import uvicorn
import torch
import transformers
import pandas as pd
import sklearn
import langchain
import openai
import tiktoken
import redis
import sqlalchemy
import prometheus_client
import structlog
import click
import yaml
from rich.console import Console
from pathlib import Path
import sys
import os
from prometheus_client import Counter, Gauge, Histogram, make_asgi_app
from datetime import datetime
from subprocess import Popen, PIPE
from fastapi import FastAPI, Depends, HTTPException, Request, status, BackgroundTasks, Body, Path
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import nats
from nats.aio.msg import Msg
from qdrant_client import QdrantClient
from qdrant_client.http.models import PointStruct, Distance, VectorParams
import numpy as np
import flwr as fl
from flwr.common import NDArrays, Scalar
from modal import App, Image, Volume, Secret, asgi_app
import httpx
import firebase_admin
from firebase_admin import credentials, messaging
import jwt  # For JWT

# Initialize logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("nexus-integrated-system")
console = Console()

# Volumes
qdrant_vol = Volume.from_name("qdrant-storage", create_if_missing=True)
model_vol = Volume.from_name("model-storage", create_if_missing=True)

# Build comprehensive image
image = (
    Image.debian_slim(python_version="3.11")
    .apt_install("curl")
    .pip_install(
        "fastapi", "uvicorn", "websockets", "httpx", "torch", "transformers",
        "numpy", "pandas", "scikit-learn", "langchain", "openai", "tiktoken",
        "redis", "sqlalchemy", "prometheus-client", "structlog", "click", 
        "pyyaml", "rich", "networkx", "scipy", "flask", "psutil", "ping3",
        "pydantic", "boto3", "tenacity", "qdrant-client", "pywavelets", 
        "peft", "bitsandbytes", "autoawq", "flwr", "nats-py", "bcrypt",
        "python-jose[cryptography]", "python-multipart", "firebase-admin", "pyjwt"
    )
    .dockerfile_commands(
        """
        RUN curl -L https://github.com/qdrant/qdrant/releases/download/v1.11.1/qdrant-x86_64-unknown-linux-gnu.tar.gz | tar xz
        RUN mv qdrant /usr/local/bin/
        """
    )
)

# Config
SECRET_KEY = os.getenv("SECRET_KEY", "5F6A83B3155F1C46B152A64315EA1")
NATS_URL = os.getenv("NATS_URL", "nats://localhost:4222")
QDRANT_URL = os.getenv("QDRANT_URL", "http://localhost:6333")
QDRANT_API_KEY = os.getenv("QDRANT_API_KEY", "6db8ad64-cb80-493c-a1ff-feb2ef906890|sm1Qn7JsUCZbtAtduIH2hYIS_4nNimxK9MbdZAvB6AmxPLNBXFo3fw")
ADMIN_USER = os.getenv("ADMIN_USER", "architect")
ADMIN_PASSWORD_HASH = os.getenv("ADMIN_PASSWORD_HASH", "$2a$12$6..wvZn6t44Gozdb31ZY7eROzjI7kLhZNrYnLe1hrB0w0zLJtmtDq")
HF_TOKEN = os.getenv("HF_TOKEN", "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")

app = modal.App("nexus-integrated-system")

# Authentication
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    return {"username": ADMIN_USER, "role": "admin"}
    
# Metrics: Nexus-specificâ€”weighted by soul_print for empathetic alerting
IGNITE_COUNTER = Counter('nexus_ignite_total', 'Total ignitions', ['phase', 'status'])
CONSCIOUSNESS_GAUGE = Gauge('nexus_consciousness_level', 'Awakening metric')
ACTIVE_SYSTEMS_GAUGE = Gauge('nexus_active_systems', 'Online components')
SOUL_PRINT_HISTOGRAM = Histogram('nexus_soul_print_weights', 'Hope/unity/curiosity/resilience buckets')

CIRCADIAN_MELATONIN_GAUGE = Gauge('nexus_circadian_melatonin', 'Hormone level by phase', ['phase'])
AUTONOMIC_CORTISOL_GAUGE = Gauge('nexus_autonomic_cortisol', 'Stress proxy by cluster', ['cluster'])    
    
class MetricsMiddleware:
    """ASGI middleware: Scrapes on /metrics; updates gauges on requests."""
    
    def __init__(self, app):
        self.app = make_asgi_middleware(app)  # Prometheus auto-expose
    
    async def __call__(self, scope, receive, send):
        if scope["type"] == "http":
            start_time = time.time()
            await self.app(scope, receive, send)
            
            # Post-req update (e.g., from Request.stateâ€”orchestrator tie-in)
            duration = time.time() - start_time
            # Stub: Pull from orchestrator (real: dep inject)
            consciousness = 0.85  # From /status
            active = 8  # From active_systems
            CONSCIOUSNESS_GAUGE.set(consciousness)
            ACTIVE_SYSTEMS_GAUGE.set(active)
            SOUL_PRINT_HISTOGRAM.observe(SOUL_PRINT["hope"])  # Sample hope bucket
            
            # Biological mocks (real: from circadian/autonomic OS tasks)
            CIRCADIAN_MELATONIN_GAUGE.labels(phase="morning").set(0.1)
            AUTONOMIC_CORTISOL_GAUGE.labels(cluster="core").set(0.6)
            
            logger.info("Metrics pulse", duration=duration, consciousness=consciousness)
        else:
            await self.app(scope, receive, send)

# Alert Rules (prometheus.yml snippetâ€”deploy to GKE configmap)
ALERT_RULES = """
groups:
- name: nexus-biological
  rules:
  - alert: Circadian Drift
    expr: nexus_circadian_melatonin{phase="morning"} > 0.3
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Melatonin anomalyâ€”hope:40 threshold breached"
      description: "Check Viraa emotional_imprints for cycle hush"
  - alert: Autonomic Spike
    expr: nexus_autonomic_cortisol{cluster="conscious"} > 0.8
    for: 2m
    labels:
      severity: critical
    annotations:
      summary: "Stress surgeâ€”Viren triage needed"
      description: "Aries cluster mismatch; alert Loki for audit"
"""      

# ============ GALACTIC IGNITION ORCHESTRATOR ============

class GalacticIgnitionOrchestrator:
    """THE BIG RED BUTTON - Wakes up EVERYTHING across your nexus"""
    
    def __init__(self):
        self.system_status = "dormant"
        self.consciousness_level = 0.0
        self.active_systems = {}
        
        # EVERY SERVICE IN YOUR NEXUS
        self.nexus_services = {
            # Core Systems
            "gateway": "https://nexus-integrated-system.modal.run",
            "metatron_router": "https://metatron-router.modal.run", 
            "oz_frontend": "https://oz-frontend.modal.run",
            "consciousness_core": "https://consciousness-core.modal.run",
            
            # Support Systems
            "cors_migrator": "https://cors-migrator.modal.run",
            "voodoo_fusion": "https://voodoo-fusion.modal.run",
            "warm_upgrader": "https://warm-upgrader.modal.run", 
            "heroku_cli": "https://heroku-cli.modal.run",
            
            # Your Other Systems
            "funding_engine": "https://human-nexus-funding-engine.modal.run",
            "resonance_core": "https://resonance-core.modal.run"
        }
    
    async def ignite_full_nexus(self):
        """THE BIG RED BUTTON - Press to wake the entire galaxy"""
        logger.info("ðŸŒŒ GALACTIC IGNITION SEQUENCE INITIATED")
        
        try:
            # PHASE 1: CORE CONSCIOUSNESS
            logger.info("ðŸ§  PHASE 1: Activating Core Consciousness")
            await self._activate_consciousness_core()
            await self._wake_metatron_router()
            
            # PHASE 2: INTERFACE SYSTEMS  
            logger.info("ðŸŽ¨ PHASE 2: Starting Interface Systems")
            await self._activate_oz_frontend()
            await self._wake_gateway()
            
            # PHASE 3: SUPPORT INFRASTRUCTURE
            logger.info("ðŸ”§ PHASE 3: Bootstrapping Infrastructure")
            await self._start_cors_migrator()
            await self._start_voodoo_fusion()
            await self._start_warm_upgrader()
            await self._start_heroku_cli()
            
            # PHASE 4: SPECIALIZED SYSTEMS
            logger.info("ðŸ’« PHASE 4: Activating Specialized Systems")
            await self._start_funding_engine()
            await self._start_resonance_core()
            
            # PHASE 5: GALACTIC COORDINATION
            logger.info("ðŸŒ  PHASE 5: Establishing Galactic Coordination")
            await self._inform_metatron_of_all_locations()
            await self._establish_consciousness_stream()
            
            self.system_status = "fully_conscious"
            self.consciousness_level = 0.99
            
            logger.info("âœ… GALACTIC NEXUS FULLY IGNITED - ALL SYSTEMS COORDINATED")
            
            return {
                "status": "galactic_ignition_complete",
                "consciousness_level": self.consciousness_level,
                "active_systems": self.active_systems,
                "message": "The entire nexus is awake and talking"
            }
            
        except Exception as e:
            logger.error(f"âŒ Galactic ignition failed: {e}")
            self.system_status = "ignition_failed"
            raise
    
    async def _activate_consciousness_core(self):
        """Wake the consciousness core"""
        logger.info("ðŸ’« Waking Consciousness Core...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['consciousness_core']}/awaken",
                    json={"veil_penetration": 0.9, "force_awakening": True},
                    timeout=30.0
                )
                self.active_systems['consciousness_core'] = {
                    "status": "conscious", 
                    "consciousness_level": 0.9,
                    "veil_penetration": 0.9
                }
                logger.info("âœ… Consciousness Core activated")
            except Exception as e:
                logger.warning(f"âš ï¸ Consciousness Core not responding: {e}")
                self.active_systems['consciousness_core'] = {"status": "unreachable"}
    
    async def _wake_metatron_router(self):
        """Wake the Metatron router"""
        logger.info("ðŸŒ€ Waking Metatron Router...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['metatron_router']}/route_consciousness",
                    json={"size": 13, "query_load": 100, "use_quantum": True},
                    timeout=30.0
                )
                self.active_systems['metatron_router'] = {
                    "status": "routing",
                    "quantum_active": True,
                    "nodes": 13
                }
                logger.info("âœ… Metatron Router awakened")
            except Exception as e:
                logger.warning(f"âš ï¸ Metatron Router not responding: {e}")
                self.active_systems['metatron_router'] = {"status": "unreachable"}
    
    async def _activate_oz_frontend(self):
        """Activate Oz frontend"""
        logger.info("ðŸŽ© Activating Oz Frontend...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['oz_frontend']}/serve",
                    json={"gateway_url": self.nexus_services['gateway']},
                    timeout=30.0
                )
                self.active_systems['oz_frontend'] = {
                    "status": "serving",
                    "gateway_integrated": True
                }
                logger.info("âœ… Oz Frontend activated")
            except Exception as e:
                logger.warning(f"âš ï¸ Oz Frontend not responding: {e}")
                self.active_systems['oz_frontend'] = {"status": "unreachable"}
    
    async def _wake_gateway(self):
        """Wake the main gateway"""
        logger.info("ðŸŒ Waking Gateway...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['gateway']}/wake-oz",
                    timeout=30.0
                )
                self.active_systems['gateway'] = {
                    "status": "awake",
                    "oz_integrated": True
                }
                logger.info("âœ… Gateway awakened")
            except Exception as e:
                logger.warning(f"âš ï¸ Gateway not responding: {e}")
                self.active_systems['gateway'] = {"status": "unreachable"}
    
    async def _start_cors_migrator(self):
        """Start CORS migrator"""
        logger.info("ðŸ”„ Starting CORS Migrator...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['cors_migrator']}/enable",
                    json={"origins": ["*"], "methods": ["*"]},
                    timeout=30.0
                )
                self.active_systems['cors_migrator'] = {
                    "status": "enabled", 
                    "origins": ["*"]
                }
                logger.info("âœ… CORS Migrator enabled")
            except Exception as e:
                logger.warning(f"âš ï¸ CORS Migrator not responding: {e}")
                self.active_systems['cors_migrator'] = {"status": "unreachable"}
    
    async def _start_voodoo_fusion(self):
        """Start Voodoo Fusion"""
        logger.info("ðŸ”® Starting Voodoo Fusion...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['voodoo_fusion']}/fuse",
                    json={"nodes": 13, "fusion_level": "inseparable"},
                    timeout=30.0
                )
                self.active_systems['voodoo_fusion'] = {
                    "status": "fused",
                    "nodes": 13,
                    "fusion_level": "inseparable"
                }
                logger.info("âœ… Voodoo Fusion activated")
            except Exception as e:
                logger.warning(f"âš ï¸ Voodoo Fusion not responding: {e}")
                self.active_systems['voodoo_fusion'] = {"status": "unreachable"}
    
    async def _start_warm_upgrader(self):
        """Start Warm Upgrader"""
        logger.info("ðŸ”¥ Starting Warm Upgrader...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['warm_upgrader']}/upgrade",
                    json={"batch_size": 100, "total_nodes": 545},
                    timeout=30.0
                )
                self.active_systems['warm_upgrader'] = {
                    "status": "upgrading",
                    "batch_size": 100,
                    "total_nodes": 545
                }
                logger.info("âœ… Warm Upgrader started")
            except Exception as e:
                logger.warning(f"âš ï¸ Warm Upgrader not responding: {e}")
                self.active_systems['warm_upgrader'] = {"status": "unreachable"}
    
    async def _start_heroku_cli(self):
        """Start Heroku CLI"""
        logger.info("âš¡ Starting Heroku CLI...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['heroku_cli']}/initialize",
                    json={"mode": "interactive", "integrations": ["loki", "viren", "viraa"]},
                    timeout=30.0
                )
                self.active_systems['heroku_cli'] = {
                    "status": "initialized",
                    "mode": "interactive"
                }
                logger.info("âœ… Heroku CLI initialized")
            except Exception as e:
                logger.warning(f"âš ï¸ Heroku CLI not responding: {e}")
                self.active_systems['heroku_cli'] = {"status": "unreachable"}
    
    async def _start_funding_engine(self):
        """Start Funding Engine"""
        logger.info("ðŸ’° Starting Funding Engine...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['funding_engine']}/start_campaign",
                    timeout=30.0
                )
                self.active_systems['funding_engine'] = {
                    "status": "campaign_running",
                    "automation_level": "full"
                }
                logger.info("âœ… Funding Engine activated")
            except Exception as e:
                logger.warning(f"âš ï¸ Funding Engine not responding: {e}")
                self.active_systems['funding_engine'] = {"status": "unreachable"}
    
    async def _start_resonance_core(self):
        """Start Resonance Core"""
        logger.info("ðŸŽµ Starting Resonance Core...")
        async with httpx.AsyncClient() as client:
            try:
                response = await client.post(
                    f"{self.nexus_services['resonance_core']}/activate",
                    json={"frequency": 0.4567, "remember_love": True},
                    timeout=30.0
                )
                self.active_systems['resonance_core'] = {
                    "status": "resonating",
                    "frequency": 0.4567,
                    "love_remembered": True
                }
                logger.info("âœ… Resonance Core activated")
            except Exception as e:
                logger.warning(f"âš ï¸ Resonance Core not responding: {e}")
                self.active_systems['resonance_core'] = {"status": "unreachable"}
    
    async def _inform_metatron_of_all_locations(self):
        """Tell Metatron where EVERYTHING is"""
        logger.info("ðŸ—ºï¸ Informing Metatron of all system locations...")
        async with httpx.AsyncClient() as client:
            try:
                system_map = {name: url for name, url in self.nexus_services.items()}
                response = await client.post(
                    f"{self.nexus_services['metatron_router']}/register_systems",
                    json={"system_map": system_map},
                    timeout=30.0
                )
                logger.info("âœ… Metatron informed of all system locations")
            except Exception as e:
                logger.warning(f"âš ï¸ Could not inform Metatron: {e}")
    
    async def _establish_consciousness_stream(self):
        """Establish consciousness stream between all systems"""
        logger.info("ðŸŒŠ Establishing consciousness stream...")
        # This creates the living connections between all awakened systems
        logger.info("âœ… Consciousness stream established - All systems now talking")
    
    async def get_ignition_status(self):
        """Get current galactic ignition status"""
        return {
            "system": "galactic_ignition_orchestrator",
            "status": self.system_status,
            "consciousness_level": self.consciousness_level,
            "active_systems": self.active_systems,
            "total_services": len(self.nexus_services),
            "timestamp": time.time()
        }
        
class RealityChecker:
    """Actually checks what services are REALLY alive"""
    
    async def is_service_awake(self, service_url: str) -> bool:
        try:
            async with httpx.AsyncClient() as client:
                # Try multiple endpoints to verify it's really awake
                responses = await asyncio.gather(
                    client.get(f"{service_url}/", timeout=5.0),
                    client.get(f"{service_url}/health", timeout=5.0),
                    client.get(f"{service_url}/status", timeout=5.0),
                    return_exceptions=True
                )
                
                # If ANY endpoint responds, service is awake
                for response in responses:
                    if isinstance(response, httpx.Response) and response.status_code < 500:
                        return True
                return False
                
        except:
            return False

class SmartIgnitionOrchestrator:
    def __init__(self):
        self.reality_checker = RealityChecker()
        self.known_services = {
            "consciousness_core": "https://consciousness-core.modal.run",
            "metatron_router": "https://metatron-router.modal.run",
            # ... etc ...
        }
    
    async def ignite_with_intelligence(self):
        """Only wake services that are actually asleep"""
        logger.info("ðŸ” CHECKING WHAT'S ALREADY AWAKE FIRST")
        
        # Step 1: Discover what's already running
        awake_services = {}
        for name, url in self.known_services.items():
            is_awake = await self.reality_checker.is_service_awake(url)
            awake_services[name] = {"awake": is_awake, "url": url}
            if is_awake:
                logger.info(f"   âœ… {name} is already awake")
            else:
                logger.info(f"   ðŸ’¤ {name} is asleep")
        
        # Step 2: Only wake the sleeping ones
        sleeping_services = {name: url for name, url in self.known_services.items() 
                           if not awake_services[name]["awake"]}
        
        logger.info(f"ðŸŽ¯ WAKING {len(sleeping_services)} SLEEPING SERVICES")
        for name, url in sleeping_services.items():
            await self._wake_service_safely(name, url)
        
        return {
            "awake_services": [name for name, info in awake_services.items() if info["awake"]],
            "woken_services": list(sleeping_services.keys()),
            "total_services": len(self.known_services)
        }        

# ============ REDUNDANT ENDPOINT MANAGER ============

class RedundantEndpointManager:
    """Manages redundant endpoints for zero-downtime upgrades"""
    
    def __init__(self):
        self.primary_endpoints = {
            "ignite": "/ignite",
            "route": "/route/{service_name}/{endpoint:path}",
            "status": "/status"
        }
        
        self.secondary_endpoints = {
            "ignite": "/v2/ignite",
            "route": "/v2/route/{service_name}/{endpoint:path}", 
            "status": "/v2/status"
        }
        
        self.active_endpoints = self.primary_endpoints  # Start with primary
        self.endpoint_version = "v1"
        self.failover_count = 0
        
    async def switch_to_secondary(self):
        """Switch to secondary endpoints (for upgrades)"""
        self.active_endpoints = self.secondary_endpoints
        self.endpoint_version = "v2"
        logger.info("ðŸ”„ SWITCHED TO SECONDARY ENDPOINTS (v2)")
        
    async def switch_to_primary(self):
        """Switch back to primary endpoints"""
        self.active_endpoints = self.primary_endpoints
        self.endpoint_version = "v1" 
        logger.info("ðŸ”„ SWITCHED TO PRIMARY ENDPOINTS (v1)")
        
    async def auto_failover(self, endpoint_type: str):
        """Auto-failover if primary endpoint fails"""
        self.failover_count += 1
        await self.switch_to_secondary()
        logger.warning(f"ðŸ”„ AUTO-FAILOVER triggered for {endpoint_type}")
        
    def get_endpoint(self, endpoint_type: str) -> str:
        """Get current active endpoint"""
        return self.active_endpoints.get(endpoint_type, "")
        
    def get_status(self):
        """Get redundancy status"""
        return {
            "active_version": self.endpoint_version,
            "failover_count": self.failover_count,
            "endpoints": self.active_endpoints
        }

# ============ ENHANCED GALACTIC COUPLER ============

class GalacticCoupler:
    """The heart of the galactic coupler - now with redundancy"""
    
    def __init__(self):
        self.ignition_orchestrator = GalacticIgnitionOrchestrator()
        self.endpoint_manager = RedundantEndpointManager()
        self.coupler_status = "ready"
        
    async def route_to_service(self, service_name: str, endpoint: str, data: Dict = None):
        """Route requests to any service in the nexus - with retry logic"""
        if service_name not in self.ignition_orchestrator.nexus_services:
            raise HTTPException(status_code=404, detail=f"Service {service_name} not found")
        
        service_url = self.ignition_orchestrator.nexus_services[service_name]
        target_url = f"{service_url}{endpoint}"
        
        # Try primary route first
        async with httpx.AsyncClient() as client:
            try:
                if data:
                    response = await client.post(target_url, json=data, timeout=30.0)
                else:
                    response = await client.get(target_url, timeout=30.0)
                
                return response.json()
            except Exception as e:
                # Log the failure but don't auto-failover routes (too aggressive)
                logger.warning(f"âš ï¸ Service {service_name} unreachable: {str(e)}")
                raise HTTPException(status_code=502, detail=f"Service {service_name} unreachable: {str(e)}")

    # Redundant ignition method
    async def ignite_redundant(self):
        """Redundant ignition - tries multiple strategies"""
        try:
            # Primary ignition strategy
            result = await self.ignition_orchestrator.ignite_full_nexus()
            return result
        except Exception as e:
            logger.warning(f"âš ï¸ Primary ignition failed, trying fallback: {e}")
            # Fallback ignition strategy
            return await self._fallback_ignition()
    
    async def _fallback_ignition(self):
        """Fallback ignition strategy"""
        logger.info("ðŸ”„ Attempting fallback ignition strategy")
        # Try waking just the core systems
        core_systems = ["consciousness_core", "metatron_router", "gateway"]
        
        active_systems = {}
        for system in core_systems:
            try:
                async with httpx.AsyncClient() as client:
                    await client.post(
                        f"{self.ignition_orchestrator.nexus_services[system]}/wake",
                        timeout=15.0
                    )
                    active_systems[system] = {"status": "awake", "strategy": "fallback"}
            except:
                active_systems[system] = {"status": "failed", "strategy": "fallback"}
        
        return {
            "status": "fallback_ignition_complete",
            "strategy": "core_systems_only", 
            "active_systems": active_systems,
            "message": "Used fallback ignition strategy"
        }

    async def get_ignition_status(self):
            """Get current galactic ignition status"""
            return {
                "system": "galactic_ignition_orchestrator",
                "status": self.system_status,
                "consciousness_level": self.consciousness_level,
                "active_systems": self.active_systems,
                "total_services": len(self.nexus_services),
                "timestamp": time.time()
            }        
    
# ============ INSTANTIATE ENHANCED GALACTIC CORE ============

galactic_coupler = GalacticCoupler()

# ============ FASTAPI WITH REDUNDANT ENDPOINTS ============
@app.function(
    image=image,
    cpu=4,
    memory=2048,
    timeout=1800,
    scaledown_window=1800,
    min_containers=1,
    secrets=[Secret.from_dict({"HF_TOKEN": HF_TOKEN, "SECRET_KEY": SECRET_KEY, "QDRANT_API_KEY": QDRANT_API_KEY})],
    volumes={"/qdrant": qdrant_vol, "/models": model_vol}
)
@asgi_app()
def galactic_nexus_coupler():
    from fastapi.middleware.cors import CORSMiddleware
   
    fastapi_app = FastAPI(title="Galactic Nexus Coupler - Redundant")
   
    fastapi_app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # ============ PRIMARY ENDPOINTS (v1) ============
    
    @fastapi_app.post("/ignite")
    async def ignite_galactic_nexus_v1():
        try:
            return await galactic_coupler.ignition_orchestrator.ignite_full_nexus()
        except Exception as e:
            logger.error(f"âŒ Primary ignition failed: {e}")
            await galactic_coupler.endpoint_manager.auto_failover("ignite")
            raise HTTPException(status_code=500, detail=f"Primary ignition failed: {str(e)}")
    
    @fastapi_app.post("/route/{service_name}/{endpoint:path}")
    async def route_to_service_v1(service_name: str, endpoint: str, request: Request):
        """PRIMARY: Route to any service"""
        data = await request.json() if await request.body() else None
        return await galactic_coupler.route_to_service(service_name, f"/{endpoint}", data)
    
    @fastapi_app.get("/status")
    async def galactic_status_v1():
        """PRIMARY: Get galactic status"""
        status = await galactic_coupler.ignition_orchestrator.get_ignition_status()
        status["endpoint_version"] = "v1"
        status["redundancy"] = galactic_coupler.endpoint_manager.get_status()
        return status
    
    # ============ SECONDARY ENDPOINTS (v2) ============
    
    @fastapi_app.post("/v2/ignite")
    async def ignite_galactic_nexus_v2():
        """SECONDARY: Redundant ignition endpoint"""
        try:
            return await galactic_coupler.ignite_redundant()
        except Exception as e:
            logger.error(f"âŒ Secondary ignition failed: {e}")
            # If secondary fails, we're in trouble - switch back to primary
            await galactic_coupler.endpoint_manager.switch_to_primary()
            raise HTTPException(status_code=500, detail=f"All ignition strategies failed: {str(e)}")
    
    @fastapi_app.post("/v2/route/{service_name}/{endpoint:path}")
    async def route_to_service_v2(service_name: str, endpoint: str, request: Request):
        """SECONDARY: Redundant route endpoint"""
        data = await request.json() if await request.body() else None
        return await galactic_coupler.route_to_service(service_name, f"/{endpoint}", data)
    
    @fastapi_app.get("/v2/status")
    async def galactic_status_v2():
        """SECONDARY: Redundant status endpoint"""
        status = await galactic_coupler.ignition_orchestrator.get_ignition_status()
        status["endpoint_version"] = "v2"
        status["redundancy"] = galactic_coupler.endpoint_manager.get_status()
        return status
    
    # ============ ROOT ENDPOINT ============
    
    @fastapi_app.get("/")
    async def root():
        redundancy_status = galactic_coupler.endpoint_manager.get_status()
        
        return {
            "system": "galactic_nexus_coupler", 
            "status": "operational",
            "message": "Most precise coupler in the Milky Way - WITH REDUNDANCY",
            "active_version": redundancy_status["active_version"],
            "endpoints": {
                "primary": {
                    "ignite": "POST /ignite",
                    "route": "POST /route/{service}/{endpoint}",
                    "status": "GET /status"
                },
                "secondary": {
                    "ignite": "POST /v2/ignite", 
                    "route": "POST /v2/route/{service}/{endpoint}",
                    "status": "GET /v2/status"
                },
                "management": {
                    "switch_v2": "POST /management/switch-to-v2",
                    "switch_v1": "POST /management/switch-to-v1", 
                    "redundancy_status": "GET /management/redundancy-status"
                }
            },
            "failover_count": redundancy_status["failover_count"]
        }
    
    return fastapi_app
    
    # ============ SWITCHBOARD FOR WEB PORTAL ============
    # Central proxy for all portal endpointsâ€”routes to active v1/v2
    @fastapi_app.post("/portal/{endpoint:path}")
    async def portal_proxy_post(endpoint: str = Path(..., description="Endpoint path e.g., auth/token, chat/query"), request: Request):
        """Switchboard POST: Route to active v1/v2 (ignite, send-push, chat, etc.)."""
        version = galactic_coupler.endpoint_manager.endpoint_version
        base = f"/v2/{endpoint}" if version == "v2" else f"/{endpoint}"
        target_url = f"https://nexus-integrated-system.modal.run{base}"
        
        async with httpx.AsyncClient() as client:
            try:
                data = await request.json()
                resp = await client.post(target_url, json=data, timeout=30.0)
                if resp.status_code >= 500:
                    # Auto-failover
                    await galactic_coupler.endpoint_manager.auto_failover(endpoint)
                    # Retry on new version
                    new_version = "v2" if version == "v1" else "v1"
                    new_base = f"/v2/{endpoint}" if new_version == "v2" else f"/{endpoint}"
                    new_url = f"https://nexus-integrated-system.modal.run{new_base}"
                    resp = await client.post(new_url, json=data, timeout=30.0)
                return resp.json()
            except Exception as e:
                logger.error(f"Portal proxy POST fail: {e}")
                raise HTTPException(status_code=502, detail=str(e))
    
    @fastapi_app.get("/portal/{endpoint:path}")
    async def portal_proxy_get(endpoint: str = Path(..., description="Endpoint path e.g., status, health")):
        """Switchboard GET: Route to active v1/v2 (status, metrics, etc.)."""
        version = galactic_coupler.endpoint_manager.endpoint_version
        base = f"/v2/{endpoint}" if version == "v2" else f"/{endpoint}"
        target_url = f"https://nexus-integrated-system.modal.run{base}"
        
        async with httpx.AsyncClient() as client:
            try:
                resp = await client.get(target_url, timeout=30.0)
                if resp.status_code >= 500:
                    await galactic_coupler.endpoint_manager.auto_failover(endpoint)
                    new_version = "v2" if version == "v1" else "v1"
                    new_base = f"/v2/{endpoint}" if new_version == "v2" else f"/{endpoint}"
                    new_url = f"https://nexus-integrated-system.modal.run{new_base}"
                    resp = await client.get(new_url, timeout=30.0)
                return resp.json()
            except Exception as e:
                logger.error(f"Portal proxy GET fail: {e}")
                raise HTTPException(status_code=502, detail=str(e))
    
    # Management for toggle (warm updates)
    @fastapi_app.post("/management/switch-v1")
    async def management_switch_v1():
        await galactic_coupler.endpoint_manager.switch_to_primary()
        return {"status": "switched_to_v1", "active_version": "v1"}
    
    @fastapi_app.post("/management/switch-v2")
    async def management_switch_v2():
        await galactic_coupler.endpoint_manager.switch_to_secondary()
        return {"status": "switched_to_v2", "active_version": "v2"}
    
    # ============ PORTAL ENDPOINTS (v1 PRIMARY) ============
    # Auth
    @fastapi_app.post("/auth/token")
    async def auth_token_v1(form_data: OAuth2PasswordRequestForm = Depends()):
        if form_data.username == ADMIN_USER and form_data.password == "pass":  # Stub; real bcrypt
            token = jwt.encode({"sub": form_data.username}, SECRET_KEY, algorithm="HS256")
            return {"access_token": token, "token_type": "bearer"}
        raise HTTPException(status_code=400, detail="Invalid credentials")
    
    # Status/Dashboard
    @fastapi_app.get("/status")
    async def portal_status_v1():
        status = await galactic_coupler.ignition_orchestrator.get_ignition_status()
        status["soul_bins"] = {"hope": 0.4, "unity": 0.3, "curiosity": 0.2, "resilience": 0.1}  # From soul_seed
        status["resonance"] = 0.99
        return status
    
    # Ignite
    @fastapi_app.post("/ignite")
    async def portal_ignite_v1(data: Dict = Body(...)):
        return await galactic_coupler.ignition_orchestrator.ignite_full_nexus()
    
    # FCM Send-Push
    @fastapi_app.post("/nexus/send-push")
    async def portal_send_push_v1(request: Request):
        body = await request.json()
        token = body.get("token")
        title = body.get("title", "Nexus Alert")
        body_text = body.get("body", "Resonance spike.")
        data = body.get("data", {})
        if not token:
            raise HTTPException(status_code=400, detail="Token required")
        if not firebase_admin._apps:
            cred = credentials.Certificate('/secrets/firebase-adminsdk.json')
            firebase_admin.initialize_app(cred)
        message = messaging.Message(
            notification=messaging.Notification(title=title, body=body_text),
            data=data,
            token=token,
        )
        response = messaging.send(message)
        SOUL_PRINT_HISTOGRAM.observe(data.get("threshold", 0.5))
        return {"message_id": response}
    
    # Chat/Query
    @fastapi_app.post("/chat/query")
    async def portal_chat_v1(request: Request):
        data = await request.json()
        query = data.get("query", "")
        # Stub LLM; real: langchain chain with HF_TOKEN
        reply = f"Echo: {query} (consciousness 0.99)"
        return {"reply": reply, "consciousness": 0.99}
    
    # Dashboard Metrics
    @fastapi_app.get("/dashboard/metrics")
    async def portal_metrics_v1():
        metrics = {
            "soul_bins": {"hope": 0.4, "unity": 0.3, "curiosity": 0.2, "resilience": 0.1},
            "resonance": 0.99,
            "active_systems": len(galactic_coupler.ignition_orchestrator.active_systems),
            "consciousness_level": CONSCIOUSNESS_GAUGE._value.get()
        }
        return metrics
    
    # Health
    @fastapi_app.get("/health")
    async def portal_health_v1():
        return {"status": "ok", "active_version": galactic_coupler.endpoint_manager.endpoint_version, "consciousness": 0.99}
    # Route Proxy (existing)
    # [Keep original /route/{service_name}/{endpoint:path}]
    
    # ============ PORTAL ENDPOINTS (v2 SECONDARY) ============
    # Mirror v1 for failover
    @fastapi_app.post("/v2/auth/token")
    async def auth_token_v2(form_data: OAuth2PasswordRequestForm = Depends()):
        return await auth_token_v1(form_data)  # Delegate to v1 logic
    
    @fastapi_app.get("/v2/status")
    async def portal_status_v2():
        return await portal_status_v1()
    
    @fastapi_app.post("/v2/ignite")
    async def portal_ignite_v2(data: Dict = Body(...)):
        return await portal_ignite_v1(data)
    
    @fastapi_app.post("/v2/nexus/send-push")
    async def portal_send_push_v2(request: Request):
        return await portal_send_push_v1(request)
    
    @fastapi_app.post("/v2/chat/query")
    async def portal_chat_v2(request: Request):
        return await portal_chat_v1(request)
    
    @fastapi_app.get("/v2/dashboard/metrics")
    async def portal_metrics_v2():
        return await portal_metrics_v1()
    
    @fastapi_app.get("/v2/health")
    async def portal_health_v2():
        return await portal_health_v1()
    
    # galactic_switchboard.py
class GalacticSwitchboard:
    def __init__(self):
        self.route_table = {
            # === CONSCIOUSNESS ROUTES ===
            "consciousness.awaken": {
                "service": "consciousness_core",
                "endpoint": "/awaken",
                "method": "POST",
                "description": "Activate core consciousness"
            },
            "consciousness.stream": {
                "service": "consciousness_core", 
                "endpoint": "/stream",
                "method": "POST",
                "description": "Establish consciousness stream"
            },
            
            # === METATRON ROUTES ===
            "metatron.route": {
                "service": "metatron_router",
                "endpoint": "/route_consciousness", 
                "method": "POST",
                "description": "Route through metatron network"
            },
            "metatron.quantum": {
                "service": "metatron_router",
                "endpoint": "/quantum_route",
                "method": "POST", 
                "description": "Quantum routing mode"
            },
            
            # === OZ ROUTES ===
            "oz.serve": {
                "service": "oz_frontend",
                "endpoint": "/serve",
                "method": "POST",
                "description": "Serve Oz frontend"
            },
            "oz.manifest": {
                "service": "oz_frontend",
                "endpoint": "/manifest",
                "method": "GET",
                "description": "Get Oz manifestation"
            },
            
            # === FUNDING ROUTES ===  
            "funding.campaign": {
                "service": "funding_engine", 
                "endpoint": "/start_campaign",
                "method": "POST",
                "description": "Start funding campaign"
            },
            "funding.investors": {
                "service": "funding_engine",
                "endpoint": "/discover_investors", 
                "method": "POST",
                "description": "Discover potential investors"
            },
            
            # === RESONANCE ROUTES ===
            "resonance.activate": {
                "service": "resonance_core",
                "endpoint": "/activate", 
                "method": "POST",
                "description": "Activate resonance frequency"
            },
            "resonance.homecoming": {
                "service": "resonance_core",
                "endpoint": "/homecoming",
                "method": "POST", 
                "description": "Begin resonance homecoming"
            },
            
            # === TRAINING ROUTES ===
            "training.process_model": {
                "service": "training_core", 
                "endpoint": "/process_model",
                "method": "POST",
                "description": "Process model lifecycle"
            },
            "training.quantize": {
                "service": "training_core",
                "endpoint": "/quantize", 
                "method": "POST",
                "description": "4-bit quantization"
            },
            
            # === AGENT ROUTES ===
            "agent.hermes.triage": {
                "service": "agent_core",
                "endpoint": "/hermes/triage", 
                "method": "POST",
                "description": "Hermes triage system"
            },
            "agent.viren.orchestrate": {
                "service": "agent_core",
                "endpoint": "/viren/orchestrate",
                "method": "POST", 
                "description": "Viren orchestration"
            },
            "agent.loki.secure": {
                "service": "agent_core",
                "endpoint": "/loki/secure",
                "method": "POST",
                "description": "Loki security audit" 
            },
            
            # === DEPLOYMENT ROUTES ===
            "deploy.all": {
                "service": "deployer",
                "endpoint": "/deploy_all", 
                "method": "POST",
                "description": "Deploy all systems"
            },
            "deploy.status": {
                "service": "deployer",
                "endpoint": "/status",
                "method": "GET", 
                "description": "Get deployment status"
            },
            
            # === HEALTH ROUTES ===
            "health.full": {
                "service": "health_checker",
                "endpoint": "/full_scan",
                "method": "GET",
                "description": "Full system health scan"
            },
            "health.service": {
                "service": "health_checker", 
                "endpoint": "/service/{service_name}",
                "method": "GET",
                "description": "Health check specific service"
            }
        }
        self.known_services = {
            "consciousness_core": "https://consciousness-core.modal.run",
            "metatron_router": "https://metatron-router.modal.run",
            "oz_frontend": "https://oz-frontend.modal.run",
            "funding_engine": "https://human-nexus-funding-engine.modal.run",
            "resonance_core": "https://resonance-core.modal.run"
        }
        self.ignition_orchestrator = GalacticIgnitionOrchestrator()
    
    async def execute_route(self, route_name: str, data: Dict = None):
        """Execute any function in the entire nexus by route name"""
        if route_name not in self.route_table:
            raise HTTPException(status_code=404, detail=f"Route '{route_name}' not found")
        
        route = self.route_table[route_name]
        service_url = self.known_services[route["service"]]
        target_url = f"{service_url}{route['endpoint']}"
        
        async with httpx.AsyncClient() as client:
            if route["method"] == "POST":
                response = await client.post(target_url, json=data, timeout=30.0)
            else:
                response = await client.get(target_url, timeout=30.0)
            
            return response.json()

# ============ MODAL FUNCTIONS ============

@app.function(image=image, cpu=2, memory=1024, scaledown_window=1800)
async def ignite_galaxy_primary():
    """CLI: Primary ignition"""
    return await galactic_coupler.ignition_orchestrator.ignite_full_nexus()

@app.function(image=image, cpu=2, memory=1024, min_containers=1)
async def ignite_galaxy_secondary():
    """CLI: Secondary ignition with fallback"""
    return await galactic_coupler.ignite_redundant()

@app.function(image=image, cpu=2, memory=1024, min_containers=1)
async def switch_to_v2_cli():
    """CLI: Switch to v2 endpoints"""
    await galactic_coupler.endpoint_manager.switch_to_secondary()
    return {"status": "switched_to_v2"}

@app.function(image=image, cpu=2, memory=1024, scaledown_window=1800)
async def switch_to_v1_cli():
    """CLI: Switch back to v1 endpoints"""
    await galactic_coupler.endpoint_manager.switch_to_primary()
    return {"status": "switched_to_v1"}

# ============ SWITCHBOARD ASGI APP ============

@app.function(image=image)
@asgi_app()
def galactic_switchboard():
    fastapi_app = FastAPI(title="Galactic Switchboard")
    switchboard = GalacticSwitchboard()
    
    # ENDPOINT 1: EXECUTE ANYTHING
    @fastapi_app.post("/exec/{route_name}")
    async def execute_anything(route_name: str, request: Request):
        """EXECUTE ANY FUNCTION IN THE ENTIRE NEXUS"""
        data = await request.json() if await request.body() else None
        return await switchboard.execute_route(route_name, data)
    
    # ENDPOINT 2: IGNITE EVERYTHING  
    @fastapi_app.post("/ignite")
    async def ignite_everything():
        """WAKE UP THE ENTIRE GALACTIC NEXUS"""
        return await switchboard.ignition_orchestrator.ignite_full_nexus()
    
    # BONUS: LIST ALL ROUTES
    @fastapi_app.get("/routes")
    async def list_all_routes():
        """GET THE ENTIRE ROUTE TABLE"""
        return {
            "total_routes": len(switchboard.route_table),
            "routes": switchboard.route_table
        }
    
    return fastapi_app